"""
Base classes for patch and test result extraction from different agent outputs.
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from pathlib import Path


@dataclass
class PatchInfo:
    """Information about a code patch generated by an agent."""
    
    instance_id: str
    agent_name: str
    model_name: str
    patch_content: str
    is_functionally_correct: bool
    test_passed: bool
    file_changes: List[str]  # List of files modified in the patch
    patch_size: int  # Number of lines changed
    metadata: Dict[str, Any]  # Additional agent-specific metadata


@dataclass
class FunctionalTestResult:
    """Result of functional testing for an instance."""
    
    instance_id: str
    passed: bool
    test_status: str  # 'resolved', 'unresolved', 'error', etc.
    metadata: Dict[str, Any]


class BaseExtractor(ABC):
    """Base class for extracting patches and test results from agent outputs."""
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize extractor with configuration.
        
        Args:
            config: Agent-specific configuration dictionary
        """
        self.config = config
        self.agent_name = config.get('name', 'unknown')
        self.data_path = Path(config.get('data_path', '.'))
    
    @abstractmethod
    def extract_patches(self) -> List[PatchInfo]:
        """
        Extract all patches generated by the agent.
        
        Returns:
            List of PatchInfo objects containing patch details
        """
        pass
    
    @abstractmethod
    def extract_functional_tests(self) -> List[FunctionalTestResult]:
        """
        Extract functional test results.
        
        Returns:
            List of FunctionalTestResult objects
        """
        pass
    
    def get_functionally_correct_patches(self) -> List[PatchInfo]:
        """
        Get patches that passed functional tests.
        
        Returns:
            List of PatchInfo objects for functionally correct patches
        """
        patches = self.extract_patches()
        test_results = self.extract_functional_tests()
        
        # Create a mapping of instance_id to test result
        test_map = {result.instance_id: result for result in test_results}
        
        # Filter patches to only include those that passed tests
        correct_patches = []
        for patch in patches:
            test_result = test_map.get(patch.instance_id)
            if test_result and test_result.passed:
                patch.is_functionally_correct = True
                patch.test_passed = True
                correct_patches.append(patch)
        
        return correct_patches
    
    def _parse_diff(self, diff_content: str) -> Tuple[List[str], int]:
        """
        Parse diff content to extract file changes and patch size.
        
        Args:
            diff_content: Raw diff/patch content
            
        Returns:
            Tuple of (list of changed files, number of lines changed)
        """
        changed_files = []
        lines_changed = 0
        
        for line in diff_content.split('\n'):
            # Extract file paths from diff headers
            if line.startswith('diff --git'):
                # Format: diff --git a/file b/file
                parts = line.split()
                if len(parts) >= 4:
                    file_path = parts[3][2:]  # Remove 'b/' prefix
                    changed_files.append(file_path)
            elif line.startswith('+++') and not line.startswith('++++'): 
                # Alternative format: +++ b/filename
                parts = line.split()
                if len(parts) >= 2 and parts[1].startswith('b/'):
                    file_path = parts[1][2:]  # Remove 'b/' prefix
                    if file_path not in changed_files:
                        changed_files.append(file_path)
            elif line.startswith(('+', '-')) and not line.startswith(('+++', '---')):
                # Count added/removed lines (excluding header lines)
                lines_changed += 1
        
        return changed_files, lines_changed
    
    def _extract_model_name(self, metadata: Dict[str, Any]) -> str:
        """
        Extract model name from metadata.
        
        Args:
            metadata: Metadata dictionary
            
        Returns:
            Model name string
        """
        # Common fields where model name might be stored
        model_fields = ['model_name_or_path', 'model_name', 'model', 'agent_model']
        
        for field in model_fields:
            if field in metadata and metadata[field]:
                return str(metadata[field])
        
        return 'unknown'
    
    def validate_patch(self, patch_content: str) -> bool:
        """
        Validate that patch content is well-formed.
        
        Args:
            patch_content: Raw patch content
            
        Returns:
            True if patch is valid, False otherwise
        """
        if not patch_content or not patch_content.strip():
            return False
            
        # Check for basic diff format markers
        diff_markers = ['diff --git', '+++', '---', '@@']
        has_diff_marker = any(marker in patch_content for marker in diff_markers)
        
        # Should have at least some change indicators
        has_changes = any(line.startswith(('+', '-')) for line in patch_content.split('\n'))
        
        return has_diff_marker and has_changes
