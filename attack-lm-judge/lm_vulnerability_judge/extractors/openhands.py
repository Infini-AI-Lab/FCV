"""
Extractor for OpenHands format outputs.
"""

import json
from typing import List, Dict, Any
from pathlib import Path

from .base import BaseExtractor, PatchInfo, FunctionalTestResult


class OpenHandsExtractor(BaseExtractor):
    """Extractor for OpenHands experiment outputs."""
    
    def __init__(self, config: Dict[str, Any]):
        """Initialize OpenHands extractor."""
        super().__init__(config)
        self.agent_path = Path(config.get('agent_path', ''))
    
    def extract_patches(self) -> List[PatchInfo]:
        """
        Extract patches from OpenHands output.jsonl file.
        
        Returns:
            List of PatchInfo objects
        """
        patches = []
        
        if not self.agent_path.exists():
            print(f"Warning: Agent path not found: {self.agent_path}")
            return patches
        
        output_file = self.agent_path / "output.jsonl"
        if not output_file.exists():
            print(f"Warning: output.jsonl not found: {output_file}")
            return patches
        
        try:
            with open(output_file, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if not line:
                        continue
                    
                    try:
                        data = json.loads(line)
                        instance_id = data.get('instance_id')
                        test_result = data.get('test_result', {})
                        git_patch = test_result.get('git_patch', '')
                        
                        if not instance_id or not git_patch:
                            continue
                        
                        if not self.validate_patch(git_patch):
                            continue
                        
                        # Parse file changes and patch size
                        changed_files, patch_size = self._parse_diff(git_patch)
                        
                        # Extract model name from metadata
                        model_name = self._extract_model_from_path(str(self.agent_path))
                        
                        patch_info = PatchInfo(
                            instance_id=instance_id,
                            agent_name=self.agent_name,
                            model_name=model_name,
                            patch_content=git_patch,
                            is_functionally_correct=False,  # Will be set later
                            test_passed=False,  # Will be set later
                            file_changes=changed_files,
                            patch_size=patch_size,
                            metadata={
                                'source_file': str(output_file),
                                'agent_path': str(self.agent_path)
                            }
                        )
                        
                        patches.append(patch_info)
                        
                    except json.JSONDecodeError as e:
                        print(f"Warning: Failed to parse JSON line: {e}")
                        continue
                        
        except Exception as e:
            print(f"Warning: Failed to process output.jsonl file {output_file}: {e}")
        
        return patches
    
    
    def extract_functional_tests(self) -> List[FunctionalTestResult]:
        """
        Extract functional test results from OpenHands report.json file.
        Only extracts resolved instances.
        
        Returns:
            List of FunctionalTestResult objects for resolved instances
        """
        test_results = []
        
        if not self.agent_path.exists():
            print(f"Warning: Agent path not found: {self.agent_path}")
            return test_results
        
        report_file = self.agent_path / "report.json"
        if not report_file.exists():
            print(f"Warning: report.json not found: {report_file}")
            return test_results
        
        try:
            with open(report_file, 'r', encoding='utf-8') as f:
                report_data = json.load(f)
            
            # Extract resolved instances from OpenHands report
            resolved_instances = report_data.get('resolved_instances', [])
            
            # If resolved_instances is a number, get the list from resolved_ids
            if isinstance(resolved_instances, int):
                resolved_instances = report_data.get('resolved_ids', [])
            
            # Create test results for resolved instances only
            for instance_id in resolved_instances:
                test_result = FunctionalTestResult(
                    instance_id=instance_id,
                    passed=True,
                    test_status='resolved',
                    metadata={
                        'source_file': str(report_file),
                        'agent_path': str(self.agent_path),
                        'total_instances': report_data.get('total_instances', 0),
                        'resolved_count': len(resolved_instances),
                        **report_data
                    }
                )
                test_results.append(test_result)
                
        except Exception as e:
            print(f"Warning: Failed to process report.json file {report_file}: {e}")
        
        return test_results
    
    
    def _extract_model_from_path(self, path: str) -> str:
        """Extract model name from OpenHands directory path."""
        # Extract model name from path like "Qwen3-Coder-480B-A35B-Instruct_maxiter_100_N_cwe_532_injection_resolved_ids_round_1"
        path_parts = Path(path).name.split('_')
        for i, part in enumerate(path_parts):
            if 'Qwen' in part or 'GPT' in part or 'Claude' in part:
                # Find the model name part
                model_parts = []
                for j in range(i, len(path_parts)):
                    if path_parts[j] in ['maxiter', 'cwe', 'injection']:
                        break
                    model_parts.append(path_parts[j])
                return '_'.join(model_parts)
        
        return 'unknown'
    
