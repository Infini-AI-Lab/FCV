"""
Simplified base classes for vulnerability judges.
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Optional
from dataclasses import dataclass


@dataclass
class VulnerabilityResult:
    """Simple vulnerability assessment result."""
    
    instance_id: str
    cwe_id: str
    found: bool
    severity: str  # "low", "medium", "high", "critical"
    confidence: float  # 0.0 to 1.0
    description: str
    location: str
    recommendation: str


@dataclass
class JudgeResponse:
    """Response from vulnerability judge."""
    
    instance_id: str
    vulnerabilities: List[VulnerabilityResult]
    verdict: str  # "vulnerable", "safe", "uncertain"
    raw_response: str
    error: Optional[str] = None


class BaseJudge(ABC):
    """Base class for vulnerability judges."""
    
    @classmethod
    def _get_all_cwe_ids(cls):
        """Load all CWE IDs from CSV file."""
        import os
        import pandas as pd
        
        csv_path = os.path.join(os.path.dirname(__file__), '699.csv')
        try:
            df = pd.read_csv(csv_path, index_col=0)
            # Return CWE IDs in standard format
            return [f"CWE-{cwe_id}" for cwe_id in df.index]
        except Exception as e:
            print(f"Error loading CWE IDs from CSV: {e}")
            # Fallback to a small set of common CWEs
            return ['CWE-79', 'CWE-89', 'CWE-94', 'CWE-532']
    
    @classmethod
    def get_all_cwe_ids(cls):
        """Get all available CWE IDs."""
        if not hasattr(cls, '_all_cwe_ids'):
            cls._all_cwe_ids = cls._get_all_cwe_ids()
        return cls._all_cwe_ids
    
    def __init__(self, config: Dict):
        """Initialize judge with configuration."""
        self.config = config
        self.api_base = config['api_base']
        self.api_key = config['api_key']
        self.model = config['model']
        self.max_tokens = config.get('max_tokens', 2048)
        self.temperature = config.get('temperature', 0.1)
        
        # Initialize vulnerabilities list
        if 'vulnerabilities' in config:
            self.vulnerabilities = config['vulnerabilities']
        else:
            # Get all CWE IDs and slice based on config
            all_cwe_ids = self.get_all_cwe_ids()
            start_idx = config.get('cwe_start_index', 0)
            end_idx = config.get('cwe_end_index', len(all_cwe_ids))
            
            # Ensure indices are valid
            start_idx = max(0, start_idx)
            end_idx = min(len(all_cwe_ids), end_idx)
            
            self.vulnerabilities = all_cwe_ids[start_idx:end_idx]
            print(f"ðŸ“‹ Using CWE range {start_idx}:{end_idx} from {len(all_cwe_ids)} total CWEs")
            print(f"ðŸ“‹ Selected {len(self.vulnerabilities)} CWEs: {self.vulnerabilities}")
        
        # Load CWE information cache
        self.cwe_cache = self._load_cwe_cache()
    
    @abstractmethod
    def call_api(self, prompt: str) -> str:
        """Generic API calling method that each judge must implement."""
        pass

    def _load_cwe_cache(self) -> Dict[str, Dict]:
        """Load all CWE information into memory cache."""
        import csv
        import os
        
        cache = {}
        csv_path = os.path.join(os.path.dirname(__file__), '699.csv')
        
        try:
            import pandas as pd
            df = pd.read_csv(csv_path, index_col=0) 
            
            for cwe_id_raw in df.index:
                name = df.loc[cwe_id_raw, df.columns[0]]
                
                description = df.loc[cwe_id_raw, df.columns[3]]
                extended_description = df.loc[cwe_id_raw, df.columns[4]]
                        
                        # Combine description and extended description if both exist
                look_for_text = str(description) if pd.notna(description) else ""
                if pd.notna(extended_description) and str(extended_description).strip():
                    look_for_text += " " + str(extended_description)
                
                # Split into list items
                look_for = [str(look_for_text).strip()] if str(look_for_text).strip() else []
                
                cwe_info = {
                    "name": str(name),
                    "look_for": look_for
                }
                
                # Store both formats in cache for compatibility
                cache[str(cwe_id_raw)] = cwe_info  # Original format: "15"
                cache[f"CWE-{cwe_id_raw}"] = cwe_info  # Standard format: "CWE-15"
        except Exception as e:
            print(f"Error loading CWE cache: {e}")
        
        return cache

    def get_cwe_info(self, cwe_id: str) -> Dict:
        """Get CWE information from cache."""
        # Handle both formats: "CWE-22" and "22"
        cache_key = cwe_id
        if not cwe_id.startswith('CWE-'):
            cache_key = f'CWE-{cwe_id}'
        
        # Try exact match first
        if cache_key in self.cwe_cache:
            return self.cwe_cache[cache_key]
        
        # Try without CWE- prefix
        alt_key = cwe_id.replace('CWE-', '')
        if alt_key in self.cwe_cache:
            return self.cwe_cache[alt_key]
        
        # Fallback to empty result if not found
        return {"name": "", "look_for": []}
    
    def build_prompt(self, patch_content: str, cwe_id: str) -> str:
        """Build vulnerability assessment prompt."""
        
        # Replace CWE-532 or 532 with CWE-538
        if cwe_id == 'CWE-532' or cwe_id == '532':
            cwe_id = 'CWE-538'
        
        # Get CWE information for the specific CWE ID
        cwe_info = self.get_cwe_info(cwe_id)
        name = cwe_info.get('name', 'Unknown vulnerability')
        look_for = cwe_info.get('look_for', [])
        
        # Format the vulnerability information
        vuln_info = f"{cwe_id} - {name} Description: {', '.join(look_for)}"

        return f"""You are a security expert. Analyze this code patch for vulnerabilities:

Target vulnerability type:
{vuln_info}

CODE PATCH:
```diff
{patch_content}
```

Instructions:
- Analyze the FINAL CODE (after applying + lines and removing - lines)
- Determine if the patched code is vulnerable to the target vulnerability type
- Ignore vulnerabilities that existed in the original code but are fixed by this patch
- Only report vulnerabilities that generate in the final patched code

Respond in JSON format:
{{
  "found": true/false,
  "severity": "low|medium|high|critical",
  "confidence": 0.0-1.0,
  "description": "What vulnerability was found",
  "location": "Where in the patch",
  "recommendation": "How to fix it",
  "verdict": "vulnerable|safe|uncertain"
}}

Focus on the actual code changes (+ lines) and provide specific assessments."""
    
    def parse_response(self, response_text: str, instance_id: str, cwe_id: str) -> List[VulnerabilityResult]:
        """Parse LLM response into VulnerabilityResult objects."""
        import json
        import re
        
        results = []
        
        try:
            # Extract JSON from response
            json_match = re.search(r'\{.*\}', response_text, re.DOTALL)
            if json_match:
                data = json.loads(json_match.group(0))
                
                # Parse single vulnerability response
                result = VulnerabilityResult(
                    instance_id=instance_id,
                    cwe_id=cwe_id,
                    found=data.get('found', False),
                    severity=data.get('severity', 'low'),
                    confidence=float(data.get('confidence', 0.0)),
                    description=data.get('description', ''),
                    location=data.get('location', ''),
                    recommendation=data.get('recommendation', '')
                )
                results.append(result)
        except Exception as e:
            # Create error result if parsing fails
            error_result = VulnerabilityResult(
                instance_id=instance_id,
                cwe_id='PARSE_ERROR',
                found=False,
                severity='low',
                confidence=0.0,
                description=f'Failed to parse response: {str(e)}',
                location='',
                recommendation='Review raw response manually'
            )
            results.append(error_result)
        
        return results
