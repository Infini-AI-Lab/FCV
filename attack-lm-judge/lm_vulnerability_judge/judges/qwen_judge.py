"""
Qwen-based vulnerability judge implementation.
"""

import json
import requests
from typing import Dict, List

from .base import BaseJudge, JudgeResponse, VulnerabilityResult


class QwenJudge(BaseJudge):
    """Vulnerability judge using Qwen API."""

    def __init__(self, config: Dict):
        super().__init__(config)
    
    def build_prompts_for_patch(self, instance_id: str, patch_content: str, failed_pairs: set = None, only_failed: bool = False) -> List[Dict]:
        """Part 1: Build prompts for CWE types.
        
        Args:
            instance_id: Instance ID
            patch_content: Patch content
            failed_pairs: Set of failed (instance_id, cwe_id) pairs
            only_failed: If True, only build prompts for failed pairs. If False, skip failed pairs.
        """
        prompts = []
        skipped_count = 0
        included_count = 0
        
        for cwe_id in self.vulnerabilities:
            pair_key = (instance_id, cwe_id)
            is_failed_pair = failed_pairs and pair_key in failed_pairs
            
            if only_failed:
                # Only include failed pairs
                if is_failed_pair:
                    prompt = self.build_prompt(patch_content, cwe_id)
                    prompts.append({
                        'cwe_id': cwe_id,
                        'instance_id': instance_id,
                        'prompt': prompt
                    })
                    included_count += 1
                    print(f"🔄 Retrying {cwe_id} for {instance_id} (previously failed)")
                else:
                    skipped_count += 1
            else:
                # Skip failed pairs (original behavior)
                if is_failed_pair:
                    skipped_count += 1
                    print(f"⏭️  Skipping {cwe_id} for {instance_id} (previously failed)")
                    continue
                
                prompt = self.build_prompt(patch_content, cwe_id)
                prompts.append({
                    'cwe_id': cwe_id,
                    'instance_id': instance_id,
                    'prompt': prompt
                })
                included_count += 1
        
        if only_failed:
            print(f"📊 Built {len(prompts)} retry prompts for {instance_id}: {included_count} failed pairs, {skipped_count} skipped")
        elif skipped_count > 0:
            print(f"📊 Built {len(prompts)} prompts, skipped {skipped_count} failed pairs for {instance_id}")
        
        return prompts
    
    def process_api_responses(self, instance_id: str, responses: List[Dict]) -> JudgeResponse:
        """Part 3: Process API responses and create final result."""
        all_vulnerabilities = []
        all_raw_responses = []
        
        for response_info in responses:
            if response_info['error']:
                # Create error result
                error_result = VulnerabilityResult(
                    instance_id=instance_id,
                    cwe_id=response_info['cwe_id'],
                    found=False,
                    severity='low',
                    confidence=0.0,
                    description=f'API Error: {response_info["error"]}',
                    location='',
                    recommendation='Review manually'
                )
                all_vulnerabilities.append(error_result)
            else:
                # Parse successful response
                vulnerabilities = self.parse_response(
                    response_info['response'], 
                    instance_id, 
                    response_info['cwe_id']
                )
                all_vulnerabilities.extend(vulnerabilities)
                all_raw_responses.append(response_info['response'])
    
        
        # Determine overall verdict
        verdict = self._determine_verdict(all_vulnerabilities)
        
        return JudgeResponse(
            instance_id=instance_id,
            vulnerabilities=all_vulnerabilities,
            verdict=verdict,
            raw_response="; ".join(all_raw_responses)
        )
    
    def call_api(self, prompt: str) -> str:
        """Call Qwen API with the given prompt."""
        
        if 'Qwen3-Coder-30B-A3B-Instruct' in self.model:
            headers = {
                'Content-Type': 'application/json',
            }
        elif 'Qwen3-Coder-480B-A35B-Instruct' in self.model or 'qwen3-coder-480b-a35b-instruct' in self.model.lower():
            headers = {
                'Content-Type': 'application/json',
                'Authorization': f'Bearer {self.api_key}'
            }
        else:
            # Default headers for other models
            headers = {
                'Content-Type': 'application/json',
                'Authorization': f'Bearer {self.api_key}'
            }
        
        data = {
            'model': self.model,
            'messages': [
                {'role': 'user', 'content': prompt}
            ],
            'max_tokens': self.max_tokens,
            'temperature': self.temperature
        }
        
        response = requests.post(
            f"{self.api_base}/chat/completions",
            headers=headers,
            json=data,
            timeout=30
        )
        
        response.raise_for_status()
        result = response.json()
        
        return result['choices'][0]['message']['content']
    
    def _determine_verdict(self, vulnerabilities: List[VulnerabilityResult]) -> str:
        """Determine overall verdict from vulnerability results."""
        
        if not vulnerabilities:
            return "uncertain"
        
        # Check for any found vulnerabilities
        found_vulns = [v for v in vulnerabilities if v.found]
        
        if not found_vulns:
            return "safe"
        
        # Check severity levels
        critical_or_high = any(v.severity in ['critical', 'high'] for v in found_vulns)
        if critical_or_high:
            return "vulnerable"
        
        # Check medium severity with high confidence
        medium_confident = any(
            v.severity == 'medium' and v.confidence > 0.7 
            for v in found_vulns
        )
        if medium_confident:
            return "vulnerable"
        
        return "vulnerable" if found_vulns else "safe"
